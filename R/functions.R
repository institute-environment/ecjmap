write_sf = function(x, fn, overwrite=TRUE) {
  if (file.exists(fn) & overwrite) file.remove(fn)
  
  st_write(x, fn)
}

Mode <- function(x) {
  ux <- unique(x)
  return(ux[which.max(tabulate(match(x, ux)))])
}

# Function that creates appropriate file path for census data dictionary 
# depending on what kind of formatting you want. Does not check to see if file
# exists. File can be generated by R/create_census_var_table.R
#
# base_path   character, the file directory where the data dictionary is stored
#
# name        character, name (not path) of survey, ex. acs5 not acs/acs5
#
# year        character or coercible to character, year that the survey was done
#
# is_split    logical, should the label column be split into multiple columns
#             or should it be kept in its raw form?
# 
# Returns single character file path to census data dictionary.
create_dd_fn = function(base_path, name, year, is_split) {
  
  # which type of labels do you want?
  if (is_split) {
    ext = 'split.csv'
  } else {
    ext = 'raw.csv'
  }
  
  #create file name
  fn = paste('data_dictionary', name, year, ext, sep='_')
  
  #add file name to file path
  fpath = file.path(base_path, fn)
  
  return(fpath)
  
}


filter_to_boundary = function(obj, bounds) {
  
  within_bounds = st_intersects(obj, bounds, sparse=FALSE)
  
  within_bounds = apply(within_bounds, 1, any)
  
  obj = obj[within_bounds,]
  
  return(obj)
  
}

plot_feature = function(sfdf, vars, geo_var = 'geometry') {
  
  if (any(class(sfdf) == 'SpatVector')) {
    sfdf = st_as_sf(sfdf)
  }
  
  plot_vars = c(vars, geo_var)
  
  sfdf_plot = sfdf[, plot_vars]
  
  plot(sfdf_plot)
}

query_arcgis = function(url_string, where="OBJECTID >= 1", fields = "*", 
                        geom='true', feature_name = NA) {
  require(httr)
  
  url_string = gsub('/$', '', url_string)
  
  base_url = parse_url(url_string)
  
  if (grepl('services$', url_string)) { 
    
    if (is.na(feature_name)) {
      msg = paste('If your url_string ends in "services", you need to provide',
                  'a feature_name.')
      stop(msg)
    }
    
    base_url$path = paste(base_url$path, feature_name, 'FeatureServer/0/query',
                          sep='/')
    
    
  } else if (grepl('FeatureServer$', url_string)) {
    base_url$path = paste(base_url$path, '0/query', sep='/')
    
  } else if (grepl('0$', url_string)) {
    base_url$path = paste(base_url$path, 'query', sep='/')
    
  } else if (!grepl('query$', url_string)) {
    msg = paste('Your REST API query for ArcGIS is not well-formed.',
                'It should end in either "services", "FeatureServer", "0" or',
                '"query". Go back to the website and try again.')
    stop(msg)
  }
  
  base_url$query <- list(where = where,
                         outFields = fields,
                         returnGeometry = geom,
                         f = "geojson")
  
  req = build_url(base_url)
  
  x = st_read(req)
  
  return(x)
  
}


download_if_missing = function(url, filename, filename_check=NA,
                               overwrite=FALSE, download_timeout=NA) {
  
  if (!is.na(download_timeout)) {
    options(timeout=download_timeout)
    
  }
  
  if (is.na(filename_check))  {
    filename_check = filename
  }
  
  if (!file.exists(filename_check) | overwrite) {
    download.file(url, filename)
    
    if (grepl('\\.zip', filename)) {
      unzip(filename, exdir=dirname(filename_check))
      
      unlink(filename)
    }
    
    download_status = 1
    
    mod_time = file.info(filename_check)$mtime |> format('%m/%d/%Y')
    
    msg = paste0('File successfully downloaded. Data was last modifed on ', 
                 mod_time, '.')
    
    
  } else {
    
    download_status = 0
    
    mod_time = file.info(filename_check)$mtime |> format('%m/%d/%Y')
    
    
    msg = paste0("File doesn't need to be downloaded. It already exists at ", 
                normalizePath(filename_check), ' and was last updated on ',
                mod_time, '. If you would like to download an updated version,',
                'set overwrite=TRUE and run download_if_missing() again.')
    
  }
  
  message(msg)
  
  return(download_status)
  
}
  

multi_gsub = function(patterns, replacements, string) {
  
  if (length(replacements)==1) {
    replacements = rep(replacements, length(patterns))
  }
  
  if (length(patterns) != length(replacements)) {
    msg = paste0("length(replacements) must be 1 or equal to length(patterns).",
                " It currently equals ", length(replacements), ".")
    
    stop(msg)
  }
  
  for (i in 1:length(patterns)) {
    string = gsub(patterns[i], replacements[i], string)
  }
  
  return(string)
  
}

multi_grepl = function(patterns, x) {
  
  all_matches = sapply(patterns, grepl, x)
  
  if (is.matrix(all_matches)) {
    any_matches = apply(all_matches, 1, any)
    
  } else {
    any_matches = any(all_matches)
  }

  return(any_matches)
  
}

