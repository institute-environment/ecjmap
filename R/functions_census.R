source('R/functions.R')

# Add descriptions of variables to ACS census data from the acs data dictionary.
# data dictionary can be created with R/create_census_var_table.R. This should
# only really be called from inside import_census().
#
# tab   tibbl or simple features, whatever the output of get_acs() is
# dict  data.table, data dictionary 
#
# Returns tabular data with labels from the data dictionary added on. If any
# column of the data dictionary contains all the same value, it is removed. The
# exception to this being the concept column which is always all the same and 
# helps you know what kind of data you are working with.
add_desc = function(tab, dict, remove_redundant) {
  require('data.table')
  
  # extract first leter from variable name, tells us which type of table
  # we are working with (detailed or subject)
  tab_letter = substr(tab$variable[1], 1, 1)
  
  # column names for labeling columns
  lab_vars = names(dict)[grepl('label', names(dict))]
  
  # all the columns we care about
  voi = c('variable', 'concept', lab_vars)
  
  # filter dictionary to either only contain variables for detailed tables or
  # subject tables
  if (tab_letter == 'B') {
    dict = dict[type=='detailed', ..voi]
  } else if (tab_letter == 'S') {
    dict = dict[type=='subject', ..voi]
  } else {
    stop('This only works with detailed (B) or subject (S) tables.')
  }
  
  # add labels to census data
  if ('sf' %in% class(tab)) {
    labeled_tab = merge(tab, dict, by='variable')
  } else {
    labeled_tab = merge(dict, tab, by='variable')
  }
  
  
  #determine which columns have more than one unique value
  if (remove_redundant) {
    has_multiple_vals = sapply(labeled_tab, function(v) length(unique(v)) > 1)
  } else {
    has_multiple_vals = rep(TRUE, ncol(labeled_tab))
  }
  
  
  #select only those
  final_voi = names(labeled_tab)[has_multiple_vals]
  
  # add concept back in
  final_voi = union(final_voi, c('variable', 'concept'))
  
  #subset table to only include multivalued cols and concept
  if ('sf' %in% class(tab)) {
    final_tab = labeled_tab[, final_voi]
  } else {
    final_tab = labeled_tab[, ..final_voi]
  }
  
  setcolorder(final_tab, c('variable', 'concept'))
  
  return(final_tab)
  
}

# Download Data from Census API using tidycensus function get_acs() and add
# labels from census data dictionary, which can be created using 
# R/create_census_var_table.R
#
# table     character, code for table you want to download data for, 
#           ex. 'B02001'
#
# level     character, geographic level to download data for, options include
#           state, county, tract, block group, and block 
#
# survey    character, name for the survey you want to download, options include
#           acs1, acs3, and acs5
#
# year      character or coercible to one, year that the survey was done
#
# geom      logical, should the polygon for each area be returned or just the 
#           acs value estimates?
#
# api_key   character, api key from https://api.census.gov/data/key_signup.html
#           save in census_API_key.txt at top level of directory
#
# dict      data.table, generated by R/create_census_var_table.R, you can use
#           create_dd_fn() in R/functions.R to create the appropriate file name.
#
# Returns either a data.table (if geom=FALSE) or a simple features object (if 
# geom=TRUE)
import_census = function(level, survey, year, geom, api_key, dict,
                         vars=NA, table=NA, remove_redundant=TRUE) {
  require('tidycensus')
  
  #download data
  if (!is.na(vars[1])) { #by variable
    census_dd = get_acs(level,
                        variables = vars,
                        survey = survey,
                        year = year,
                        state = 'CA',
                        geometry = geom,
                        key = api_key
    )
    
  } else { # by table
    census = get_acs(level,
                     survey = survey,
                     year = year,
                     table = table,
                     state = 'CA',
                     geometry = geom,
                     key = api_key
    )
    
    # add description
    census_dd = add_desc(census, dict, remove_redundant)
  }
  
  
  
  # turn into a data.table if we didn't download geometries
  if (!geom) {
    setDT(census_dd)
  }
  
  return(census_dd)
  
}

block_group_label = function(name) {
  require('stringr')
  
  tract = str_split_i(name, '; ', 2)
  tract_num = gsub('Census Tract ', '', tract)
  
  block_group = str_split_i(name, '; ', 1)
  block_group_num = gsub('Block Group ', '', block_group)
  
  block_group_lab = paste0('Block Group ', tract_num, '-', block_group_num)
  
  return(block_group_lab)
}

format_census = function(tab) {
  require('data.table')
  
  geoid_len = nchar(tab$GEOID[1])
  
  error_msg = paste('This function only works on data with county, tract, and',
                    'block group geographies.')
  
  if (geoid_len<5) { 
    stop(error_msg)
    
  } else if (geoid_len==5) {
    setnames(tab, 'GEOID', 'COUNTYID')
    
    tab[,county:=gsub(' County, California', '', NAME)]
    
    setcolorder(tab, c('COUNTYID', 'county'))
    
  } else {
    
    name_seps = str_count(tab$NAME[1], '; ')
    
    tab[,":="(COUNTYID = substr(GEOID, 1, 5),
              county = str_split_i(NAME, '; ', name_seps))]
    
    tab[,county:=gsub(' County', '', county)]
    
    if (geoid_len == 11) {
      tab[,geom_name :=  str_split_i(NAME, '; ', 1)]
      
    } else if (geoid_len == 12) {
      
      tab[,geom_name :=  block_group_label(NAME)]
      
    } else {
      stop(error_msg)
    }
    
    setcolorder(tab, c('COUNTYID', 'county', 'GEOID', 'geom_name'))
    
  }
  
  tab$NAME = NULL
  
  return(tab)
  
}


format_census_geom = function(df, bounds=NA) {
  require('sf')
  
  df = st_transform(df, 4326)
  
  df = df[,c('GEOID', 'geometry')]
  
  if (nchar(df$GEOID[1])==5) {
    names(df)[1] = 'COUNTYID'
  }
  
  if ('sf' %in% class(bounds)) {
    
    df = filter_to_boundary(df, bounds)
    
  }
  
  return(df)
  
}


